package Chapter9.Exercises;

/**
 * 3. Создайте базовый класс с определением метода abstract print(), переопределяемого производными классами.
 * Переопределенная версия метода выводит значение переменной int, определенной в производном классе. В точке определения
 * этой переменной присвойте ей ненулевое значение. Вызовите этот метод в конструкторе базового класса. В методе main()
 * создайте объект производного типа, а затем вызовите его метод print(). Объянсите результат работы программы.
 * date: 18.10.2020
 */
abstract class BaseClass {
    abstract void print();
    BaseClass() {
        System.out.println("BaseClass constructor.");
        print();
    }
}

class DerivativeClass extends BaseClass {
    private int i = 1;
    void print() {
        System.out.println(i);
    }
}

public class Exercise3 {
    public static void main(String[] args) {
        DerivativeClass d = new DerivativeClass();
        d.print();
    }
}
/**
 * Результат работы программы:
 *
 * BaseClass constructor.
 * 0
 * 1
 *
 * Дело в том, что при создании объекта производного типа сначала вызывается конструктор базового класса, в котором
 * вызывается метод print(). Согласно абзацу из главы 8 данной книги: "Если конструктор является лишь очередным шагом на
 * пути построения объекта класса, производного от класса данного конструктора, «производные» части ещё не были
 * инициализированы на момент вызова текущего конструктора. Однако динамически связываемый вызов может перейти во
 * «внешнюю» часть иерархии, то есть к производным классам." Другими словами, в данной ситуации будет вызван
 * переопределенный метод print(), который выводит на консоль пока не проинициализированную переменную i.
 * Поэтому на данный момент ей присвоено зачение по умолчанию - 0. В консоль будет выведено "0". После этого происходит вызов
 * конструктора производного класса, а также инициализация переменной i. Далее вызывается метод print()
 * инициализированного объекта d и в консоль выводится значение "1".
 */